/* This file contains defines the main() entry point for the program. In order
 * to complete the exercises for the project, you should not need to change
 * anything in here -- modifying the functions in "project.cpp" should be
 * enough.
 */

/* We use GLEW, the OpenGL Extension Wrangler. This gives us easy access
 * to some of the newer functions that the optional exercises use.
 */
#define GLEW_STATIC 1
#include <GL/glew.h>

/* We are using the GLUT framework (technically, freeglut, a newer
 * implementation of the API defined by the original GLUT code).  
 *
 * GLUT's design requires using global variables, which is why you will 
 * encounter a few of those in here.
 */
#include <GL/glut.h>

#include "mouse.hpp"
#include "vec3D.hpp"
#include "volume.hpp"
#include "project.hpp"


/* The display callback. This function will be registered with GLUT, which will
 * call it whenever a new frame needs to be drawn and displayed.
 *
 * GLUT will automatically call it in response to various OS events, and 
 * whenever we request that our window be redrawn using `glutPostRedisplay()`.
 */
void display() 
{
	Vec3Df fwd, up, cam;
	fwd[0] = float(tb_matrix[2+4*0]);
	fwd[1] = float(tb_matrix[2+4*1]);
	fwd[2] = float(tb_matrix[2+4*2]);

	up[0] = float(tb_matrix[1+4*0]);
	up[1] = float(tb_matrix[1+4*1]);
	up[2] = float(tb_matrix[1+4*2]);

	cam[0] = float(tb_matrix[12]);
	cam[1] = float(tb_matrix[13]);
	cam[2] = float(tb_matrix[14]);

	glLoadIdentity();
	tbVisuTransform();

	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
	project_draw_window( fwd, up, cam );

	glutSwapBuffers();
}

/* Callback that is called when the window is resized. GLUT uses this to 
 * inform us whenever the user (or the OS) resizes our window, so that we
 * can react on this. In particular, we need to adjust the project matrix
 * to correspond to the new window size and aspect ratio.
 */
void reshape(int w, int h)
{
	glViewport( 0, 0, (GLsizei)w, (GLsizei)h );

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	gluPerspective( 50.f, w/(float)h, 1.f, 10.f );

	glMatrixMode( GL_MODELVIEW );
}

/* Callback that is called whenever a key press occurs.
 *
 * The "x" and "y" parameters actually contain the position of the mouse, but
 * we don't use these at the moment. (They are commented to avoid "unused
 * variable" warnings that our compiler may create for us. By not naming the
 * arguments, we indicate that we do not intend to use them.)
 */
void keyboard( unsigned char key, int /*x*/, int /*y*/ )
{
	switch (key) {

		// Escape may be used to exit the program. Escape has a keycode
		// of 27.
		case 27:
			std::exit(0);
			break;

		default: project_on_key_press( key, getCameraPosition() );
	}

	glutPostRedisplay();
}


void mouse( int button, int state, int x, int y )
{
	if( 3 == button )
		project_interact_mouse_wheel( true );
	else if( 4 == button )
		project_interact_mouse_wheel( false );
	else
		tbMouseFunc( button, state, x, y );

	glutPostRedisplay();
}

// Initialize our program
//
// This initializes GLUT, which creates a OpenGL-capable window for us to
// render to. We also register the callbacks that we defined above, so that
// GLUT can inform us regarding events generated by the OS (e.g., keypresses).
//
// Additionally, setup the default OpenGL state.
void init( int argc, char** argv ) 
{
	glutInit(&argc, argv);

	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);

	//glutInitWindowPosition(200, 100);
	glutInitWindowSize(1280,720);
	glutCreateWindow("Volume-rendering project");

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef(0,0,-4);
	tbInitTransform();
	tbHelp();

	glutReshapeFunc(reshape);
	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	glutMotionFunc(tbMotionFunc);
	glutKeyboardFunc(keyboard);

	glDisable( GL_DEPTH_TEST );

	glEnable( GL_POINT_SMOOTH );
	glHint( GL_POINT_SMOOTH_HINT, GL_NICEST );

	glClearColor(0.0, 0.0, 0.0, 0.0);
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

// Standard C/C++ main entry function.
// We call our initialization method (above) and then hand over control to
// GLUT.
int main( int argc, char* argv[] )
{
	init( argc, argv );

	if( GLEW_OK != glewInit() )
	{
		std::fprintf( stderr, "glewInit() returned error. Bye.\n" );
		return 1;
	}

	if( !project_initialize() )
	{
		std::fprintf( stderr, "project_initialize() returned error. Bye.\n" );
		return 1;
	}

	// This function never returns -- GLUT will loop forever and std::exit() if
	// the window is closed. (And we also manually std::exit() when escape is
	// pressed).
	glutMainLoop();

	// ... so this line is never reached. But that's OK - we don't try to do
	// anything at this point.
	return 0;
}
